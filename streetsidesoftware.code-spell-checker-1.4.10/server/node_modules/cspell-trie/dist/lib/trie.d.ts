import { Sequence } from 'gensequence';
import { TrieNode } from './TrieNode';
import { SuggestionCollector, SuggestionResult, CompoundWordsMethod } from './suggest';
import { WalkerIterator } from './walker';
export declare class Trie {
    readonly root: TrieNode;
    constructor(root: TrieNode);
    find(text: string, useCompounds?: boolean): TrieNode | undefined;
    findCompound(text: string): TrieNode | undefined;
    findExact(text: string): TrieNode | undefined;
    has(word: string, useCompounds?: boolean): boolean;
    /**
     * Provides an ordered sequence of words with the prefix of text.
     */
    completeWord(text: string): Sequence<string>;
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     */
    suggest(text: string, maxNumSuggestions: number, compoundMethod?: CompoundWordsMethod): string[];
    /**
     * Suggest spellings for `text`.  The results are sorted by edit distance with changes near the beginning of a word having a greater impact.
     * The results include the word and adjusted edit cost.  This is useful for merging results from multiple tries.
     */
    suggestWithCost(text: string, maxNumSuggestions: number, compoundMethod?: CompoundWordsMethod): SuggestionResult[];
    /**
     * genSuggestions will generate suggestions and send them to `collector`. `collector` is responsible for returning the max acceptable cost.
     * Costs are measured in weighted changes. A cost of 100 is the same as 1 edit. Some edits are considered cheaper.
     * Returning a MaxCost < 0 will effectively cause the search for suggestions to stop.
     */
    genSuggestions(collector: SuggestionCollector, compoundMethod?: CompoundWordsMethod): void;
    words(): Sequence<string>;
    /**
     * Allows iteration over the entire tree.
     * On the returned Iterator, calling .next(goDeeper: boolean), allows for controlling the depth.
     */
    iterate(): WalkerIterator;
    insert(word: string): this;
    static create(words: Iterable<string> | IterableIterator<string>): Trie;
}
