"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
const Rx = require("rxjs/Rx");
const stream = require("stream");
/**
 * Transform the output of an Observable into a node readable stream.
 */
function rxToStream(src, options = { encoding: 'utf8' }) {
    const trigger = new Rx.Subject();
    let depth = 0;
    const maxDepth = 100;
    const readable = new stream.Readable(__assign({}, options, { read: () => {
            trigger.next();
        } }));
    function close() {
        Rx.Observable.interval(1).take(1).subscribe(() => readable.push(null));
    }
    function next() {
        if (depth < maxDepth) {
            // Use the fastest method
            trigger.next();
        }
        else {
            // Slower to avoid running out of stack space.
            Rx.Observable.interval().take(1).subscribe(() => trigger.next());
        }
    }
    function push(data) {
        depth += 1;
        readable.push(data) ? next() : null;
        depth -= 1;
    }
    trigger
        .zip(src, (_, src) => src)
        .subscribe(
    // send the data and signal we can use more data.
    push, 
    // Close on error or complete.
    close, close);
    return readable;
}
exports.rxToStream = rxToStream;
//# sourceMappingURL=rxToStream.js.map