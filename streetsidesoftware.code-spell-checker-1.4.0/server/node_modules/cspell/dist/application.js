"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Rx = require("rxjs/Rx");
const glob = require("glob");
const minimatch = require("minimatch");
const cspell = require("./index");
const fsp = require("fs-extra");
const path = require("path");
const commentJson = require("comment-json");
const util = require("./util/util");
const matchBase = { matchBase: true };
const defaultMinimatchOptions = { nocase: true };
class CSpellApplicationConfiguration {
    constructor(files, options, emitters) {
        this.files = files;
        this.options = options;
        this.emitters = emitters;
        this.configGlob = '{cspell.json,.cspell.json}';
        this.configGlobOptions = defaultMinimatchOptions;
        this.info = emitters.info || this.info;
        this.debug = emitters.debug || this.debug;
        this.configGlob = options.config || this.configGlob;
        this.configGlobOptions = options.config ? {} : this.configGlobOptions;
        this.excludes = calcExcludeGlobInfo(options.exclude);
        this.logIssue = emitters.issue || this.logIssue;
        this.local = options.local || '';
        this.uniqueFilter = options.unique
            ? util.uniqueFilterFnGenerator((issue) => issue.text)
            : () => true;
    }
}
exports.CSpellApplicationConfiguration = CSpellApplicationConfiguration;
function lint(files, options, emitters) {
    const cfg = new CSpellApplicationConfiguration(files, options, emitters);
    return runLint(cfg);
}
exports.lint = lint;
function runLint(cfg) {
    return run();
    function run() {
        header();
        const configRx = globRx(cfg.configGlob, cfg.configGlobOptions)
            .map(util.unique)
            .do(configFiles => cfg.info(`Config Files Found:\n    ${configFiles.join('\n    ')}\n`))
            .map(filenames => ({ filename: filenames.join(' || '), config: cspell.readSettingsFiles(filenames) }))
            .map(config => {
            if (cfg.local) {
                config.config.language = cfg.local;
            }
            return config;
        })
            .share();
        // Get Exclusions from the config files.
        const exclusionGlobs = configRx
            .map(({ filename, config }) => extractGlobExcludesFromConfig(filename, config))
            .flatMap(a => a)
            .toArray()
            .map(a => a.concat(cfg.excludes))
            .toPromise();
        const filesRx = filterFiles(findFiles(cfg.files), exclusionGlobs)
            .flatMap(filename => {
            return fsp.readFile(filename).then(text => ({ text: text.toString(), filename }), error => {
                return error.code === 'EISDIR'
                    ? Promise.resolve()
                    : Promise.reject(Object.assign({}, error, { message: `Error reading file: "${filename}"` }));
            });
        })
            .filter(a => !!a)
            .map(a => a);
        const status = {
            files: 0,
            filesWithIssues: new Set(),
            issues: 0,
        };
        const r = Rx.Observable.combineLatest(configRx, filesRx, (configInfo, fileInfo) => ({ configInfo, text: fileInfo.text, filename: fileInfo.filename }))
            .map(({ configInfo, filename, text }) => {
            const ext = path.extname(filename);
            const fileSettings = cspell.calcOverrideSettings(configInfo.config, path.resolve(filename));
            const settings = cspell.mergeSettings(cspell.getDefaultSettings(), cspell.getGlobalSettings(), fileSettings);
            const languageIds = settings.languageId ? [settings.languageId] : cspell.getLanguagesForExt(ext);
            const config = cspell.constructSettingsForText(settings, text, languageIds);
            cfg.debug(`Filename: ${filename}, Extension: ${ext}, LanguageIds: ${languageIds.toString()}`);
            return { configInfo: Object.assign({}, configInfo, { config }), filename, text };
        })
            .filter(info => info.configInfo.config.enabled !== false)
            .do(() => status.files += 1)
            .flatMap(({ configInfo, filename, text }) => {
            cfg.debug(commentJson.stringify(configInfo, undefined, 2));
            return cspell.validateText(text, configInfo.config)
                .then(wordOffsets => {
                return {
                    filename,
                    issues: cspell.Text.calculateTextDocumentOffsets(filename, text, wordOffsets)
                };
            });
        })
            .do(info => {
            const { filename, issues } = info;
            cfg.info(`Checking: ${filename} ... Issues: ${issues.length}`);
            issues
                .filter(cfg.uniqueFilter)
                .forEach((issue) => cfg.logIssue(issue));
        })
            .filter(info => !!info.issues.length)
            .do(issue => status.filesWithIssues.add(issue.filename))
            .reduce((status, info) => (Object.assign({}, status, { issues: status.issues + info.issues.length })), status)
            .toPromise();
        return r;
    }
    function header() {
        cfg.info(`
cspell;
Date: ${(new Date()).toUTCString()}
Options:
    verbose:   ${yesNo(!!cfg.options.verbose)}
    config:    ${cfg.configGlob}
    exclude:   ${cfg.excludes.map(a => a.glob).join('\n             ')}
    files:     ${cfg.files}
    wordsOnly: ${yesNo(!!cfg.options.wordsOnly)}
    unique:    ${yesNo(!!cfg.options.unique)}
`);
    }
    function isExcluded(filename, globs) {
        const cwd = process.cwd();
        const relFilename = (filename.slice(0, cwd.length) === cwd) ? filename.slice(cwd.length) : filename;
        for (const glob of globs) {
            if (glob.regex.test(relFilename)) {
                cfg.info(`Excluded File: ${filename}; Excluded by ${glob.glob} from ${glob.source}`);
                return true;
            }
        }
        return false;
    }
    function filterFiles(files, excludeGlobs) {
        excludeGlobs.then(excludeGlobs => {
            const excludeInfo = excludeGlobs.map(g => `Glob: ${g.glob} from ${g.source}`);
            cfg.info(`Exclusion Globs: \n    ${excludeInfo.join('\n    ')}\n`);
        });
        return Rx.Observable.combineLatest(files, excludeGlobs, (filename, globs) => ({ filename, globs }))
            .filter(({ filename, globs }) => !isExcluded(filename, globs))
            .map(({ filename }) => filename);
    }
}
function trace(_words, _options) {
    return Promise.resolve();
}
exports.trace = trace;
function createInit(_) {
    return Promise.resolve();
}
exports.createInit = createInit;
const defaultExcludeGlobs = [
    'node_modules/**'
];
function findFiles(globPatterns) {
    const processed = new Set();
    return Rx.Observable.from(globPatterns)
        .flatMap(pattern => globRx(pattern)
        .catch((error) => {
        return new Promise((resolve) => resolve(Promise.reject(Object.assign({}, error, { message: 'Error with glob search.' }))));
    }))
        .flatMap(a => a)
        .filter(filename => !processed.has(filename))
        .do(filename => processed.add(filename));
}
function calcExcludeGlobInfo(commandLineExclude) {
    const excludes = commandLineExclude && commandLineExclude.split(/\s+/g).map(glob => ({ glob, source: 'arguments' }))
        || defaultExcludeGlobs.map(glob => ({ glob, source: 'default' }));
    return excludes.map(({ source, glob }) => ({ source, glob, regex: minimatch.makeRe(glob, matchBase) }));
}
function extractGlobExcludesFromConfig(filename, config) {
    return (config.ignorePaths || []).map(glob => ({ source: filename, glob, regex: minimatch.makeRe(glob, matchBase) }));
}
function yesNo(value) {
    return value ? 'Yes' : 'No';
}
const globRx = Rx.Observable.bindNodeCallback(glob);
//# sourceMappingURL=application.js.map