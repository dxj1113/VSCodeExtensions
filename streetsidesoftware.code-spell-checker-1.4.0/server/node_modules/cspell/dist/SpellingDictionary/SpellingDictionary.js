"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const gensequence_1 = require("gensequence");
const cspell_trie_1 = require("cspell-trie");
const repMap_1 = require("../util/repMap");
const defaultSuggestions = 10;
class SpellingDictionaryFromSet {
    constructor(words, name, options = {}) {
        this.words = words;
        this.name = name;
        this.options = options;
        this.mapWord = repMap_1.createMapper(options.repMap || []);
    }
    get trie() {
        this._trie = this._trie || cspell_trie_1.Trie.create(this.words);
        return this._trie;
    }
    has(word) {
        const mWord = this.mapWord(word).toLowerCase();
        return this.words.has(mWord);
    }
    suggest(word, numSuggestions) {
        word = word.toLowerCase();
        return this.trie.suggestWithCost(word, numSuggestions || defaultSuggestions);
    }
    get size() {
        return this.words.size;
    }
}
exports.SpellingDictionaryFromSet = SpellingDictionaryFromSet;
function createSpellingDictionary(wordList, name, options) {
    const words = new Set(gensequence_1.genSequence(wordList)
        .filter(word => typeof word === 'string')
        .map(word => word.toLowerCase().trim()));
    return new SpellingDictionaryFromSet(words, name, options);
}
exports.createSpellingDictionary = createSpellingDictionary;
function createSpellingDictionaryRx(words, name, options) {
    const promise = words
        .filter(word => typeof word === 'string')
        .map(word => word.toLowerCase().trim())
        .reduce((words, word) => words.add(word), new Set())
        .map(words => new SpellingDictionaryFromSet(words, name, options))
        .toPromise();
    return promise;
}
exports.createSpellingDictionaryRx = createSpellingDictionaryRx;
class SpellingDictionaryFromTrie {
    constructor(trie, name, options = {}) {
        this.trie = trie;
        this.name = name;
        this.options = options;
        this._size = 0;
        this.knownWords = new Set();
        this.unknownWords = new Set();
        this.mapWord = repMap_1.createMapper(options.repMap || []);
    }
    get size() {
        if (!this._size) {
            // walk the trie and get the approximate size.
            const i = this.trie.iterate();
            let deeper = true;
            for (let r = i.next(); !r.done; r = i.next(deeper)) {
                // count all nodes even though they are not words.
                // because we are not going to all the leaves, this should give a good enough approximation.
                this._size += 1;
                deeper = r.value.text.length < 5;
            }
        }
        return this._size;
    }
    has(word) {
        word = this.mapWord(word).toLowerCase();
        if (this.knownWords.has(word))
            return true;
        if (this.unknownWords.has(word))
            return false;
        const r = this.trie.has(word);
        // Cache the result.
        if (r) {
            this.knownWords.add(word);
        }
        else {
            // clear the unknown word list if it has grown too large.
            if (this.unknownWords.size > SpellingDictionaryFromTrie.unknownWordsLimit) {
                this.unknownWords.clear();
            }
            this.unknownWords.add(word);
        }
        return r;
    }
    suggest(word, numSuggestions) {
        word = word.toLowerCase();
        return this.trie.suggestWithCost(word, numSuggestions || defaultSuggestions);
    }
}
SpellingDictionaryFromTrie.unknownWordsLimit = 1000;
exports.SpellingDictionaryFromTrie = SpellingDictionaryFromTrie;
function createSpellingDictionaryTrie(data, name, options) {
    const promise = cspell_trie_1.importTrieRx(data)
        .map(node => new cspell_trie_1.Trie(node))
        .map(trie => new SpellingDictionaryFromTrie(trie, name, options))
        .take(1)
        .toPromise();
    return promise;
}
exports.createSpellingDictionaryTrie = createSpellingDictionaryTrie;
//# sourceMappingURL=SpellingDictionary.js.map