"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("./util");
var util_2 = require("./util");
exports.CompoundWordsMethod = util_2.CompoundWordsMethod;
const defaultMaxNumberSuggestions = 10;
const baseCost = 100;
const swapCost = 75;
const postSwapCost = swapCost - baseCost;
const maxNumChanges = 5;
function suggest(root, word, maxNumSuggestions = defaultMaxNumberSuggestions, compoundMethod = util_1.CompoundWordsMethod.NONE) {
    const collector = suggestionCollector(word, maxNumSuggestions);
    collector.collect(genSuggestions(root, word, compoundMethod));
    return collector.suggestions;
}
exports.suggest = suggest;
function* genSuggestions(root, word, compoundMethod = util_1.CompoundWordsMethod.NONE) {
    yield* genCompoundableSuggestions(root, word, compoundMethod);
}
exports.genSuggestions = genSuggestions;
function* genCompoundableSuggestions(root, word, compoundMethod) {
    const bc = baseCost;
    const psc = postSwapCost;
    const matrix = [[]];
    const x = ' ' + word;
    const mx = x.length - 1;
    let costLimit = Math.min(bc * word.length / 2, bc * maxNumChanges);
    for (let i = 0; i <= mx; ++i) {
        matrix[0][i] = i * baseCost;
    }
    const i = util_1.walker(root, compoundMethod);
    let deeper = true;
    for (let r = i.next(deeper); !r.done; r = i.next(deeper)) {
        const { text, node, depth } = r.value;
        const d = depth + 1;
        const lastSugLetter = d > 1 ? text[d - 2] : '';
        const w = text.slice(-1);
        const c = bc - d;
        matrix[d] = matrix[d] || [];
        matrix[d][0] = matrix[d - 1][0] + bc;
        let lastLetter = x[0];
        let min = matrix[d][0];
        for (let i = 1; i <= mx; ++i) {
            let curLetter = x[i];
            let subCost = (w === curLetter)
                ? 0
                : (curLetter === lastSugLetter ? (w === lastLetter ? psc : c) : c);
            matrix[d][i] = Math.min(matrix[d - 1][i - 1] + subCost, // substitute
            matrix[d - 1][i] + c, // insert
            matrix[d][i - 1] + c // delete
            );
            min = Math.min(min, matrix[d][i]);
            lastLetter = curLetter;
        }
        let cost = matrix[d][mx];
        if (util_1.isWordTerminationNode(node) && cost <= costLimit) {
            costLimit = (yield { word: text, cost }) || costLimit;
        }
        deeper = (min <= costLimit);
    }
}
exports.genCompoundableSuggestions = genCompoundableSuggestions;
function compSuggestionResults(a, b) {
    return a.cost - b.cost || a.word.length - b.word.length || a.word.localeCompare(b.word);
}
exports.compSuggestionResults = compSuggestionResults;
function suggestionCollector(word, maxNumSuggestions, filter = () => true) {
    const sugs = new Map();
    let maxCost = Math.min(baseCost * word.length / 2, baseCost * maxNumChanges);
    function dropMax() {
        if (sugs.size < 2) {
            sugs.clear();
            return;
        }
        const sorted = [...sugs.values()].sort(compSuggestionResults);
        const toRemove = sorted.pop();
        const maxSug = sorted.pop();
        sugs.delete(toRemove.word);
        maxCost = maxSug.cost;
    }
    function collector(suggestion) {
        const { word, cost } = suggestion;
        if (cost <= maxCost && filter(suggestion.word)) {
            if (sugs.has(word)) {
                const known = sugs.get(word);
                known.cost = Math.min(known.cost, cost);
            }
            else {
                sugs.set(word, { word, cost });
                if (sugs.size > maxNumSuggestions) {
                    dropMax();
                }
            }
        }
        return maxCost;
    }
    function collect(src) {
        let ir;
        while (!(ir = src.next(maxCost)).done) {
            if (ir.value !== undefined) {
                collector(ir.value);
            }
        }
    }
    return {
        collect,
        add: function (suggestion) { collector(suggestion); return this; },
        get suggestions() { return [...sugs.values()].sort(compSuggestionResults); },
        get maxCost() { return maxCost; },
        get word() { return word; },
    };
}
exports.suggestionCollector = suggestionCollector;
//# sourceMappingURL=suggest.js.map