"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const chai_1 = require("chai");
const trie_1 = require("./trie");
const importExport_1 = require("./importExport");
const Rx = require("rxjs/Rx");
const fs = require("fs-extra");
const path = require("path");
const zlib = require("zlib");
const cspellDict = require("cspell-dict-es-es");
let trie;
function getTrie() {
    if (!trie) {
        const configLocation = cspellDict.getConfigLocation();
        const config = fs.readFile(configLocation)
            .then(buffer => buffer.toString())
            .then(json => JSON.parse(json.replace(/\/\/.*/g, '')));
        const pathToDict = config.then(config => {
            const dictDef = config && config.dictionaryDefinitions && config.dictionaryDefinitions[0] || {};
            const dictPath = dictDef.file || '';
            return path.join(path.dirname(configLocation), dictPath);
        });
        const trieFileContents = pathToDict.then(pathToDict => fs.readFile(pathToDict))
            .then(buffer => zlib.gunzipSync(buffer))
            .then(buffer => buffer.toString('UTF-8'));
        const trieLines = Rx.Observable
            .fromPromise(trieFileContents.then(trieFileContents => trieFileContents.split('\n')))
            .flatMap(a => a);
        const trieNode = importExport_1.importTrieRx(trieLines).take(1).toPromise();
        trie = trieNode.then(node => new trie_1.Trie(node));
    }
    return trie;
}
describe('Validate Spanish Suggestions', () => {
    it('Tests suggestions', () => {
        return getTrie().then(trie => {
            // cspell:ignore Carmjen
            const results = trie.suggestWithCost('carmjen', 10);
            // console.log(JSON.stringify(results));
            const suggestions = results.map(s => s.word);
            chai_1.expect(suggestions).to.contain('carmen');
            chai_1.expect(suggestions[0]).to.be.equal('carmen');
        });
    });
});
//# sourceMappingURL=suggest-es.test.js.map