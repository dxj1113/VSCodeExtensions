"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const gensequence_1 = require("gensequence");
class SpellingDictionaryCollection {
    constructor(dictionaries, name) {
        this.dictionaries = dictionaries;
        this.name = name;
        this.dictionaries = this.dictionaries.filter(a => !!a.size);
    }
    has(word) {
        return isWordInAnyDictionary(this.dictionaries, word);
    }
    suggest(word, numSuggestions) {
        return makeSuggestions(this.dictionaries, word, numSuggestions);
    }
    get size() {
        return this.dictionaries.reduce((a, b) => a + b.size, 0);
    }
}
exports.SpellingDictionaryCollection = SpellingDictionaryCollection;
function createCollection(dictionaries, name) {
    return new SpellingDictionaryCollection(dictionaries, name);
}
exports.createCollection = createCollection;
function isWordInAnyDictionary(dicts, word) {
    return !!gensequence_1.genSequence(dicts)
        .first(dict => dict.has(word));
}
exports.isWordInAnyDictionary = isWordInAnyDictionary;
function makeSuggestions(dicts, word, numSuggestions) {
    // Make a map of the unique suggestions.  If there are duplicates, keep the lowest cost.
    const allSuggestions = gensequence_1.genSequence(dicts)
        .concatMap(dict => dict.suggest(word, numSuggestions))
        .reduceToSequence((map, sug) => {
        const cost = Math.min(sug.cost, (map.get(sug.word) || sug).cost);
        map.set(sug.word, Object.assign({}, sug, { cost }));
        return map;
    }, new Map())
        .map(([, v]) => v)
        .toArray()
        .sort((a, b) => a.cost - b.cost);
    return allSuggestions.slice(0, numSuggestions);
}
exports.makeSuggestions = makeSuggestions;
function createCollectionP(dicts, name) {
    return Promise.all(dicts)
        .then(dicts => new SpellingDictionaryCollection(dicts, name));
}
exports.createCollectionP = createCollectionP;
//# sourceMappingURL=SpellingDictionaryCollection.js.map