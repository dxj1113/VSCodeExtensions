"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
const Rx = require("rxjs/Rx");
const glob = require("glob");
const minimatch = require("minimatch");
const cspell = require("./index");
const fsp = require("fs-promise");
const path = require("path");
const commentJson = require("comment-json");
const util = require("./util/util");
;
;
class CSpellApplication {
    constructor(files, options, emitters) {
        this.files = files;
        this.options = options;
        this.emitters = emitters;
        this.configGlob = '{cspell.json,.cspell.json}';
        this.configGlobOptions = { nocase: true };
        this.info = emitters.info;
        this.debug = emitters.debug;
        this.configGlob = options.config || this.configGlob;
        this.configGlobOptions = options.config ? {} : this.configGlobOptions;
        this.excludes = this.calcExcludeGlobInfo(options.exclude);
        this.logIssue = emitters.issue;
        this.uniqueFilter = options.unique
            ? util.uniqueFilterFnGenerator((issue) => issue.text)
            : () => true;
    }
    run() {
        this.header();
        const configRx = globRx(this.configGlob, this.configGlobOptions)
            .map(util.unique)
            .do(configFiles => this.info(`Config Files Found:\n    ${configFiles.join('\n    ')}\n`))
            .map(filenames => ({ filename: filenames.join(' || '), config: cspell.readSettingsFiles(filenames) }))
            .share();
        // Get Exclusions from the config files.
        const exclusionGlobs = configRx
            .map(({ filename, config }) => CSpellApplication.extractGlobExcludesFromConfig(filename, config))
            .flatMap(a => a)
            .toArray()
            .map(a => a.concat(this.excludes))
            .toPromise();
        const filesRx = this.filterFiles(CSpellApplication.findFiles(this.files), exclusionGlobs)
            .flatMap(filename => {
            return fsp.readFile(filename).then(text => ({ text: text.toString(), filename }), error => {
                return error.code === 'EISDIR'
                    ? Promise.resolve()
                    : Promise.reject(__assign({}, error, { message: `Error reading file: "${filename}"` }));
            });
        })
            .filter(a => !!a);
        const status = {
            files: 0,
            filesWithIssues: new Set(),
            issues: 0,
        };
        const r = Rx.Observable.combineLatest(configRx, filesRx, (configInfo, fileInfo) => ({ configInfo, text: fileInfo.text, filename: fileInfo.filename }))
            .map(({ configInfo, filename, text }) => {
            const ext = path.extname(filename);
            const languageIds = cspell.getLanguagesForExt(ext);
            this.debug(`Filename: ${filename}, Extension: ${ext}, LanguageIds: ${languageIds.toString()}`);
            const settings = cspell.mergeSettings(cspell.getDefaultSettings(), configInfo.config);
            const config = cspell.constructSettingsForText(settings, text, languageIds);
            return { configInfo: __assign({}, configInfo, { config }), filename, text };
        })
            .filter(info => info.configInfo.config.enabled !== false)
            .do(() => status.files += 1)
            .flatMap(({ configInfo, filename, text }) => {
            this.debug(commentJson.stringify(configInfo, undefined, 2));
            return cspell.validateText(text, configInfo.config)
                .then(wordOffsets => {
                return {
                    filename,
                    issues: cspell.Text.calculateTextDocumentOffsets(filename, text, wordOffsets)
                };
            });
        })
            .do(info => {
            const { filename, issues } = info;
            this.info(`Checking: ${filename} ... Issues: ${issues.length}`);
            issues
                .filter(this.uniqueFilter)
                .forEach((issue) => this.logIssue(issue));
        })
            .filter(info => !!info.issues.length)
            .do(issue => status.filesWithIssues.add(issue.filename))
            .reduce((status, info) => (__assign({}, status, { issues: status.issues + info.issues.length })), status)
            .toPromise();
        return r;
    }
    static createInit(_) {
        return Promise.resolve();
    }
    header() {
        this.info(`
cspell;
Date: ${(new Date()).toUTCString()}
Options:
    verbose:   ${yesNo(!!this.options.verbose)}
    config:    ${this.configGlob}
    exclude:   ${this.excludes.map(a => a.glob).join('\n             ')}
    files:     ${this.files}
    wordsOnly: ${yesNo(!!this.options.wordsOnly)}
    unique:    ${yesNo(!!this.options.unique)}
`);
    }
    isExcluded(filename, globs) {
        const cwd = process.cwd();
        const relFilename = (filename.slice(0, cwd.length) === cwd) ? filename.slice(cwd.length) : filename;
        for (const glob of globs) {
            if (glob.regex.test(relFilename)) {
                this.info(`Excluded File: ${filename}; Excluded by ${glob.glob} from ${glob.source}`);
                return true;
            }
        }
        return false;
    }
    static findFiles(globPatterns) {
        const processed = new Set();
        return Rx.Observable.from(globPatterns)
            .flatMap(pattern => globRx(pattern)
            .catch((error) => {
            return new Promise((resolve) => resolve(Promise.reject(__assign({}, error, { message: 'Error with glob search.' }))));
        }))
            .flatMap(a => a)
            .filter(filename => !processed.has(filename))
            .do(filename => processed.add(filename));
    }
    filterFiles(files, excludeGlobs) {
        excludeGlobs.then(excludeGlobs => {
            const excludeInfo = excludeGlobs.map(g => `Glob: ${g.glob} from ${g.source}`);
            this.info(`Exclusion Globs: \n    ${excludeInfo.join('\n    ')}\n`);
        });
        return Rx.Observable.combineLatest(files, excludeGlobs, (filename, globs) => ({ filename, globs }))
            .filter(({ filename, globs }) => !this.isExcluded(filename, globs))
            .map(({ filename }) => filename);
    }
    calcExcludeGlobInfo(commandLineExclude) {
        const excludes = commandLineExclude && commandLineExclude.split(/\s+/g).map(glob => ({ glob, source: 'arguments' }))
            || CSpellApplication.defaultExcludeGlobs.map(glob => ({ glob, source: 'default' }));
        return excludes.map(({ source, glob }) => ({ source, glob, regex: minimatch.makeRe(glob) }));
    }
    static extractGlobExcludesFromConfig(filename, config) {
        return (config.ignorePaths || []).map(glob => ({ source: filename, glob, regex: minimatch.makeRe(glob) }));
    }
}
CSpellApplication.defaultExcludeGlobs = [
    'node_modules/**'
];
exports.CSpellApplication = CSpellApplication;
function yesNo(value) {
    return value ? 'Yes' : 'No';
}
const globRx = Rx.Observable.bindNodeCallback(glob);
//# sourceMappingURL=application.js.map